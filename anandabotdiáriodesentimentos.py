# -*- coding: utf-8 -*-
"""AnandaBotDi√°rioDeSentimentos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16STJL5C1PqP72r4FTHVuRq2dNj6D642K
"""

!pip install google-generativeai

for model in genai.list_models():
  print(model.name)

from IPython import get_ipython
from IPython.display import display


import os
import json
from google.colab import userdata
import google.generativeai as genai
from collections import Counter
from datetime import datetime, timedelta
from google.colab import files

!pip install googlesearch-python
from googlesearch import search

!pip install pandas
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

# Obtenha a chave da API de Colab userdata
API_KEY = userdata.get('GOOGLE_API_KEY')

# Configure a biblioteca google.generativeai com a chave da API
genai.configure(api_key=API_KEY) # Use API_KEY here

# Definir o nome do arquivo para o hist√≥rico
ARQUIVO_HISTORICO = 'historico_palavras.json'

# Inicializar historico_de_palavras como uma lista vazia.
# Ele ser√° preenchido ao carregar o arquivo.
historico_de_palavras = []

# Fun√ß√£o para carregar o hist√≥rico do arquivo
def carregar_historico(nome_arquivo):
    global historico_de_palavras # Indica que vamos modificar a vari√°vel global
    historico_de_palavras = [] # Inicializa como vazio para evitar duplicatas ao recarregar
    if os.path.exists(nome_arquivo):
        try:
            with open(nome_arquivo, 'r', encoding='utf-8') as f:
                data = json.load(f)
                # Converte as strings de data de volta para objetos datetime e adiciona campo 'sentimento' se faltar
                for entry in data:
                    if 'data' in entry and isinstance(entry['data'], str):
                        try:
                            entry['data'] = datetime.fromisoformat(entry['data'])
                        except ValueError:
                             print(f"Aviso: N√£o foi poss√≠vel converter data para datetime: {entry['data']}")
                             # Pula entradas com data inv√°lida
                             continue # Pula para a pr√≥xima entrada
                    # Se o campo 'sentimento' n√£o existir, classifique-o agora (chamada √∫nica por palavra ao carregar)
                    if 'sentimento' not in entry:
                        print(f"Classificando sentimento para palavra hist√≥rica: '{entry.get('palavra', 'N/A')}'")
                        entry['sentimento'] = classificar_sentimento_palavra(entry.get('palavra', '')) # Classifica se a palavra existir
                    historico_de_palavras.append(entry) # Adiciona a entrada (modificada ou original) ao hist√≥rico
                print(f"Hist√≥rico carregado com sucesso de {nome_arquivo}")
        except json.JSONDecodeError:
            print(f"Erro ao decodificar JSON de {nome_arquivo}. O arquivo pode estar corrompido.")
            historico_de_palavras = [] # Reinicia o hist√≥rico se o arquivo estiver corrompido
        except Exception as e:
            print(f"Ocorreu um erro ao carregar o hist√≥rico: {e}")
            historico_de_palavras = [] # Reinicia o hist√≥rico em caso de outros erros
    else:
        print(f"Arquivo de hist√≥rico {nome_arquivo} n√£o encontrado. Iniciando com hist√≥rico vazio.")
        historico_de_palavras = []

# Carregar o hist√≥rico ao iniciar o script
carregar_historico(ARQUIVO_HISTORICO)

# Fun√ß√£o para salvar o hist√≥rico no arquivo
def salvar_historico(nome_arquivo):
    try:
        # Converte objetos datetime para strings antes de salvar em JSON
        data_to_save = []
        for entry in historico_de_palavras:
            saved_entry = entry.copy() # Cria uma c√≥pia para n√£o modificar a lista original
            if 'data' in saved_entry and isinstance(saved_entry['data'], datetime):
                saved_entry['data'] = saved_entry['data'].isoformat() # Converte datetime para string ISO 8601
            data_to_save.append(saved_entry)

        with open(nome_arquivo, 'w', encoding='utf-8') as f:
            json.dump(data_to_save, f, ensure_ascii=False, indent=4) # Salva em JSON com formata√ß√£o leg√≠vel
        print(f"Hist√≥rico salvo com sucesso em {nome_arquivo}")
    except Exception as e:
        print(f"Ocorreu um erro ao salvar o hist√≥rico: {e}")


# Carregar o hist√≥rico ao iniciar o script
carregar_historico(ARQUIVO_HISTORICO)

# Fun√ß√£o para converter o hist√≥rico para DataFrame
def historico_para_dataframe(historico):
    """Converte a lista de hist√≥rico para um DataFrame pandas."""
    if not historico:
        print("Hist√≥rico vazio. N√£o √© poss√≠vel criar um DataFrame.")
        return pd.DataFrame() # Retorna um DataFrame vazio se o hist√≥rico estiver vazio

    # Converte a lista de dicion√°rios em DataFrame
    df = pd.DataFrame(historico)

    # Garante que a coluna 'data' √© do tipo datetime (se ainda n√£o for)
    # Isso √© importante para o filtro de ranking, mas tamb√©m √∫til aqui.
    # Pode ser que ao carregar do JSON a data venha como string, dependendo do ponto
    # onde esta fun√ß√£o √© chamada, por isso a convers√£o √© segura.
    df['data'] = pd.to_datetime(df['data'], errors='coerce')

    return df

# Fun√ß√£o para baixar o DataFrame como CSV
def baixar_historico_csv(dataframe, nome_arquivo="historico_palavras.csv"):
    """Salva um DataFrame em um arquivo CSV e inicia o download."""
    if dataframe.empty:
        print("DataFrame vazio. Nada para baixar.")
        return

    try:
        dataframe.to_csv(nome_arquivo, index=False, encoding='utf-8')
        print(f"Preparando download de '{nome_arquivo}'...")
        files.download(nome_arquivo)
        print("Download iniciado.")
    except Exception as e:
        print(f"Erro ao baixar o arquivo CSV: {e}")

# ... c√≥digo anterior ...

def sugerir_momentos_felizes(resumo_do_dia):
    """
    Sugere atividades para melhorar o humor com base no resumo do dia
    e resultados de busca no Google.
    """
    google_query = resumo_do_dia + " como lidar com" # Exemplo de consulta
    google_results = []
    try:
        for result in search(google_query, num_results=3): # Busca os 3 primeiros resultados
            google_results.append(result)
    except Exception as e:
        print(f"Erro na busca do Google: {e}")
        # Continua mesmo se a busca falhar, mas sem contexto do Google
        google_results = [] # Garante que google_results √© uma lista vazia em caso de erro

    # Formata os resultados da busca para incluir no prompt
    if google_results:
        # Modifica√ß√£o: Remove a descri√ß√£o dos links e foca apenas nos links em si ou em um resumo gen√©rico
        google_context = "Considere as seguintes informa√ß√µes relevantes:\n"
        for i, result in enumerate(google_results):
            # Voc√™ pode escolher como formatar. Apenas o link ou um resumo gen√©rico.
            google_context += f"- {result}\n" # Apenas o link
            # Ou, se preferir uma descri√ß√£o mais gen√©rica:
            # google_context += f"- Informa√ß√£o √∫til relacionada ao tema: {result}\n" # Usar o link como exemplo de informa√ß√£o

    else:
        google_context = "Nenhuma informa√ß√£o relevante encontrada em fontes externas.\n"


    # Prepara o prompt para o Gemini, incluindo o contexto do Google Search
    prompt_text = f"""
    Considerando o seguinte resumo do meu dia: "{resumo_do_dia}".

    {google_context} # Inclui as informa√ß√µes possivelmente relevantes

    Com base no resumo do dia e nas informa√ß√µes possivelmente √∫teis fornecidas,
    sugira 3 a 5 atividades simples, pr√°ticas e r√°pidas que eu poderia fazer agora para **ajudar a melhorar o humor ou trazer um momento de relaxamento/conforto**.
    As sugest√µes devem ser apresentadas como uma lista numerada.
    Priorize sugest√µes que sejam relevantes para o resumo do dia, usando as informa√ß√µes √∫teis como inspira√ß√£o, **mas evite mencionar explicitamente "links" ou fazer suposi√ß√µes detalhadas sobre o conte√∫do deles**.
    **Enfatize que s√£o apenas op√ß√µes para explorar e n√£o metas a serem alcan√ßadas.**
    """

    model = genai.GenerativeModel('gemini-1.5-flash')
    try:
        response = model.generate_content(prompt_text)
        return response.text
    except Exception as e:
        print(f"Erro ao gerar conte√∫do com Gemini: {e}")
        return "Desculpe, n√£o foi poss√≠vel gerar sugest√µes de momentos de bem-estar neste momento. Tente novamente mais tarde."

# ... o restante do c√≥digo ...

# Fun√ß√£o para registrar as palavras e classificar o sentimento no momento do registro
def registrar_palavras(palavras):
    data_registro = datetime.now()
    for palavra in palavras:
        # Classifica o sentimento no momento do registro para evitar chamadas futuras repetidas
        sentimento_classificado = classificar_sentimento_palavra(palavra)
        historico_de_palavras.append({
            'palavra': palavra,
            'data': data_registro,
            'sentimento': sentimento_classificado # Armazenar o sentimento classificado
        })

def analisar_sentimento(palavras):
    """
    Analisa o sentimento geral das palavras, fornece uma pontua√ß√£o
    e identifica categorias de sentimento mais espec√≠ficas.
    """
    prompt_text = f"""
    Analise o sentimento das seguintes palavras, que resumem o dia de uma pessoa: "{', '.join(palavras)}".
    Forne√ßa:
    1. Uma pontua√ß√£o de sentimento geral em uma escala de -1 (muito negativo) a 1 (muito positivo).
    2. O sentimento predominante (Positivo, Negativo ou Neutro).
    3. Categ√≥rias de sentimento mais espec√≠ficas que descrevam as palavras (ex: "grato", "cansado", "animado", "frustrado", "calmo", etc.). Liste at√© 3 categorias se aplic√°vel.
    4. Uma breve explica√ß√£o do porqu√™ esses sentimentos e a pontua√ß√£o foram identificados com base nas palavras fornecidas.

    Formate a resposta da seguinte maneira:
    Pontua√ß√£o: [pontua√ß√£o num√©rica]
    Predominante: [Sentimento Predominante]
    Categorias: [Categoria 1], [Categoria 2], ... (se houver)
    An√°lise: [Breve explica√ß√£o]

    Reconhe√ßa que todos os sentimentos s√£o v√°lidos e parte da experi√™ncia humana.
    Adicionalmente, ofere√ßa uma breve sugest√£o ou reflex√£o sobre como lidar com o sentimento identificado de forma construtiva (seja ele positivo ou negativo).
    """

    model = genai.GenerativeModel('gemini-1.5-flash')
    try:
        response = model.generate_content(prompt_text)
        return response.text
    except Exception as e:
        print(f"Erro ao gerar conte√∫do com Gemini: {e}")
        return "Desculpe, n√£o foi poss√≠vel realizar a an√°lise de sentimento neste momento."

# Fun√ß√£o para classificar o sentimento de uma √∫nica palavra
def classificar_sentimento_palavra(palavra):
    """
    Classifica o sentimento de uma √∫nica palavra como positivo, negativo ou neutro
    usando o Gemini. Retorna a classifica√ß√£o (string).
    """
    prompt_text = f"""
    Classifique a seguinte palavra em uma das categorias de sentimento: Positivo, Negativo ou Neutro.
    Palavra: "{palavra}"
    Responda apenas com a palavra da categoria de sentimento (Positivo, Negativo ou Neutro), sem explica√ß√µes adicionais.
    """
    model = genai.GenerativeModel('gemini-1.5-flash')
    try:
        response = model.generate_content(prompt_text)
        # Limpa a resposta para obter apenas a categoria (remove espa√ßos em branco, etc.)
        sentimento = response.text.strip()
        # Valida se a resposta √© uma das categorias esperadas
        if sentimento in ['Positivo', 'Negativo', 'Neutro']:
            return sentimento
        else:
            # Se a resposta n√£o for clara, consideramos neutro ou lidamos de outra forma
            print(f"Aviso: Classifica√ß√£o inesperada para '{palavra}': '{sentimento}'. Considerado Neutro.")
            return 'Neutro'
    except Exception as e:
        print(f"Erro ao classificar sentimento para '{palavra}': {e}. Considerado Neutro.")
        return 'Neutro'

# Fun√ß√£o para obter dados de frequ√™ncia de sentimento por per√≠odo
def obter_frequencia_sentimento(historico, periodo=None):
    """
    Calcula a frequ√™ncia de palavras por sentimento (Positivo, Negativo, Neutro)
    em um determinado per√≠odo, using the sentiment already classified in the history.
    """
    df = historico_para_dataframe(historico)

    if df.empty:
        print("Hist√≥rico vazio. N√£o √© poss√≠vel calcular a frequ√™ncia de sentimentos.")
        return {}

    # Filtra por per√≠odo, se especificado
    df_filtrado = df # Start with the full dataframe

    if periodo == 'semanal':
        data_limite = datetime.now() - timedelta(days=7)
        df_filtrado = df_filtrado[df_filtrado['data'] >= data_limite]
    elif periodo == 'mensal':
        data_limite = datetime.now() - timedelta(days=30) # Aproximadamente um m√™s
        df_filtrado = df_filtrado[df_filtrado['data'] >= data_limite]
    # If periodo is None or 'total', df_filtrado remains the full dataframe

    if df_filtrado.empty:
        print(f"Nenhuma palavra encontrada no per√≠odo {periodo}.")
        return {}

    # Ensure the 'sentimento' column exists and count the occurrences
    if 'sentimento' in df_filtrado.columns:
        # Use value_counts on the 'sentimento' column
        contagem_sentimento = df_filtrado['sentimento'].value_counts().to_dict()
        return contagem_sentimento
    else:
        print("Aviso: Coluna 'sentimento' n√£o encontrada no DataFrame. N√£o √© poss√≠vel calcular a frequ√™ncia de sentimentos.")
        return {}

# Fun√ß√£o para obter o ranking das palavras mais frequentes por per√≠odo
def obter_ranking_palavras(historico, periodo=None, top_n=10):
    """
    Calcula o ranking das palavras mais frequentes em um determinado per√≠odo.
    """
    df = historico_para_dataframe(historico)

    if df.empty:
        return []

    # Filtra por per√≠odo, se especificado
    if periodo == 'semanal':
        data_limite = datetime.now() - timedelta(days=7)
        df_filtrado = df[df['data'] >= data_limite]
    elif periodo == 'mensal':
        data_limite = datetime.now() - timedelta(days=30) # Aproximadamente um m√™s
        df_filtrado = df[df['data'] >= data_limite]
    else: # Per√≠odo total
        df_filtrado = df

    if df_filtrado.empty:
        print(f"Nenhuma palavra encontrada no per√≠odo {periodo}.")
        return []

    # Usa Counter para contar a frequ√™ncia das palavras
    # Achata a lista de listas (se palavras_chave fosse uma lista de listas) ou apenas conta
    # No seu caso, 'palavra' √© uma string em cada entrada do hist√≥rico
    todas_palavras = df_filtrado['palavra'].tolist()
    contagem_palavras = Counter(todas_palavras)

    # Obt√©m o ranking das palavras mais comuns
    ranking = contagem_palavras.most_common(top_n)

    return ranking

def gerar_grafico_sentimento(dados_frequencia, periodo_label="total"):
    """
    Gera um gr√°fico de barras da frequ√™ncia de sentimentos com design moderno.
    Usa cores semaf√≥ricas (Verde/Positivo, Vermelho/Negativo, Azul/Neutro).
    """
    if not dados_frequencia:
        display(Markdown("N√£o h√° dados para gerar o gr√°fico."))
        return

    # Definir as cores para cada sentimento
    cores_sentimento = {
        'Positivo': '#34a853',  # Verde do Google
        'Negativo': '#ea4335',  # Vermelho do Google
        'Neutro': '#4285f4'     # Azul do Google
    }

    # Ordenar os sentimentos para garantir a ordem das cores e barras
    ordem_sentimentos = ['Negativo', 'Neutro', 'Positivo']
    sentimentos_ordenados = [s for s in ordem_sentimentos if s in dados_frequencia]
    frequencias_ordenadas = [dados_frequencia.get(s, 0) for s in sentimentos_ordenados]
    cores_plotagem = [cores_sentimento.get(s, '#fbbc05') for s in sentimentos_ordenados] # Amarelo do Google como fallback

    # Criar um DataFrame tempor√°rio para facilitar o uso com hue
    df_grafico = pd.DataFrame({
        'Sentimento': sentimentos_ordenados,
        'Frequ√™ncia': frequencias_ordenadas
    })

    # Mapear os sentimentos para as cores para usar com hue
    # Garantimos que a ordem no mapeamento seja a mesma para a paleta
    palette_mapping = {s: cores_sentimento.get(s, '#fbbc05') for s in sentimentos_ordenados}


    # Usar um estilo de seaborn mais limpo e moderno
    sns.set_theme(style="whitegrid") # ou "white", "ticks" dependendo da prefer√™ncia

    plt.figure(figsize=(10, 6)) # Ajuste o tamanho da figura
    # Modificado: Passando 'Sentimento' para hue e usando a paleta mapeada, desativando a legenda
    ax = sns.barplot(x='Sentimento', y='Frequ√™ncia', hue='Sentimento', data=df_grafico,
                     palette=palette_mapping, alpha=0.9, legend=False)

    # Remover bordas e alguns eixos para um visual mais limpo
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    # Manter o eixo inferior (bottom) para os labels de sentimento
    ax.spines['bottom'].set_linewidth(0.5) # Linha inferior mais fina

    ax.set_facecolor('white') # Fundo branco para um visual limpo

    # Adicionar os valores de frequ√™ncia no topo de cada barra
    # Percorremos os patches do eixo para anotar
    for p in ax.patches:
        ax.annotate(f'{int(p.get_height())}', # Garante que o valor seja um inteiro
                    (p.get_x() + p.get_width() / 2., p.get_height()),
                    ha='center', va='center', xytext=(0, 8), textcoords='offset points',
                    fontsize=10, color='black') # Ajusta fonte e cor do texto

    # Melhorar os r√≥tulos e t√≠tulo
    plt.title(f'Frequ√™ncia de Sentimentos ({periodo_label.capitalize()})', fontsize=16, weight='bold', color='#3c4043') # Cor do texto do Google
    plt.xlabel('Sentimento', fontsize=12, color='#3c4043')
    plt.ylabel('Frequ√™ncia', fontsize=12, color='#3c4043')
    plt.yticks([]) # Remover ticks do eixo Y, j√° que os valores est√£o nas barras

    # Ajustar os ticks do eixo X para um visual mais limpo
    ax.tick_params(axis='x', length=0, labelsize=11, colors='#3c4043') # Remove ticks e ajusta labels

    # Layout justo para evitar cortes
    plt.tight_layout()

    plt.show()

display(Markdown("# Di√°rio de Sentimentos Interativo"))

# --- In√≠cio da Introdu√ß√£o do AnandaBot ---
display(Markdown("## Ol√°! Eu sou AnandaBot!"))
display(Markdown("Meu nome, Ananda (‡§Ü‡§®‡§®‡•ç‡§¶), vem do S√¢nscrito e significa **'bem-aventuran√ßa'**, **'alegria suprema'**."))
display(Markdown("Ananda tamb√©m foi um disc√≠pulo de Buda, conhecido por sua compaix√£o e mem√≥ria."))
display(Markdown("Estou aqui para te ajudar a refletir sobre seus sentimentos e encontrar momentos de bem-estar."))

# Coletar nome do usu√°rio
nome_usuario = input("Como voc√™ gostaria de ser chamado(a)? ")
if nome_usuario.strip():
    display(Markdown(f"Que nome bonito, **{nome_usuario.capitalize()}**!"))
else:
    nome_usuario = "pessoa querida" # Nome padr√£o se o usu√°rio n√£o digitar nada
    display(Markdown(f"Tudo bem, vou te chamar de **{nome_usuario}**."))

# Coletar data de nascimento para calcular a idade
while True:
    data_nascimento_str = input(f"Para te conhecer um pouco melhor, {nome_usuario.capitalize()}, qual √© a sua data de nascimento (formato DD/MM/AAAA)? ")
    try:
        # Tenta converter a string para um objeto datetime
        data_nascimento = datetime.strptime(data_nascimento_str, '%d/%m/%Y')

        # Calcula a idade
        hoje = datetime.now()
        idade = hoje.year - data_nascimento.year - ((hoje.month, hoje.day) < (data_nascimento.month, data_nascimento.day))

        display(Markdown(f"Que legal! Ent√£o voc√™ tem **{idade}** anos!"))
        break # Sai do loop se a data for v√°lida
    except ValueError:
        display(Markdown("<p style='color:red;'>Formato de data inv√°lido. Por favor, use o formato DD/MM/AAAA (ex: 01/01/2000).</p>"))

display(Markdown(f"\nPronto para come√ßar nosso di√°rio de sentimentos, {nome_usuario.capitalize()}?"))

# --- Fim da Introdu√ß√£o do AnandaBot ---
from IPython.display import display, Markdown
display(Markdown("# Di√°rio de Sentimentos Interativo"))

while True:
    # Modifique a string do menu_markdown para incluir o nome do usu√°rio
    menu_markdown = f"""
---
## Ol√°, {nome_usuario.capitalize()}! O que voc√™ gostaria de fazer hoje?

1.  **Resumir meu dia e obter sugest√µes de bem-estar** (resumo geral, sem registro no hist√≥rico)
2.  **Registrar 5 palavras-chave do meu dia e analisar sentimento** (para hist√≥rico e an√°lise de frequ√™ncia)
3.  **Ver hist√≥rico de palavras**
4.  **Baixar hist√≥rico como CSV**
5.  **Ver ranking das palavras mais frequentes**
6.  **Ver frequ√™ncia de sentimentos (gr√°fico)**
7.  **Limpar hist√≥rico de palavras**
8.  **Sair**
"""
    display(Markdown(menu_markdown))

    escolha = input("Digite o n√∫mero da sua escolha: ")

    if escolha == '1':
        display(Markdown("---"))
        resumo_dia_geral = input("Como foi seu dia hoje (em um breve resumo)? ")

        if resumo_dia_geral.strip():
            # Usa o resumo geral para an√°lise de sentimento e sugest√µes,
            # mas ESTE RESUMO N√ÉO VAI PARA O HIST√ìRICO DE PALAVRAS.
            analise_md = analisar_sentimento([resumo_dia_geral]) # Analisa o resumo como uma "palavra" ou frase
            display(Markdown("### An√°lise do seu dia:"))
            display(Markdown(analise_md))

            sugestoes_md = sugerir_momentos_felizes(resumo_dia_geral)
            display(Markdown("### Sugest√µes para um momento de bem-estar:"))
            display(Markdown(sugestoes_md))
        else:
            display(Markdown("<p style='color:orange;'>Por favor, digite um breve resumo do seu dia.</p>"))

    elif escolha == '2':
        display(Markdown("---"))
        palavras_chave_input = input("Digite 5 palavras-chave que resumem seu dia (separe por v√≠rgula): ")
        # Processa a entrada em palavras, removendo espa√ßos e convertendo para min√∫sculas
        palavras_chave = [p.strip().lower() for p in palavras_chave_input.split(',') if p.strip()]

        if len(palavras_chave) == 5:
            # Registra AS 5 PALAVRAS-CHAVE no hist√≥rico para frequ√™ncia e ranking
            registrar_palavras(palavras_chave)
            salvar_historico(ARQUIVO_HISTORICO)
            display(Markdown("<p style='color:green;'>Palavras-chave registradas no hist√≥rico.</p>"))

            # Analisa o sentimento APENAS das 5 palavras-chave
            analise_palavras_md = analisar_sentimento(palavras_chave)
            display(Markdown("### An√°lise baseada nas 5 palavras-chave:"))
            display(Markdown(analise_palavras_md))

        else:
            display(Markdown("<p style='color:orange;'>Por favor, digite exatamente 5 palavras-chave separadas por v√≠rgula.</p>"))

    elif escolha == '3':
        display(Markdown("---"))
        if historico_de_palavras:
            output_md = "## Hist√≥rico de Palavras\n\n"
            output_md += "| Data e Hora       | Palavra          | Sentimento        |\n"
            output_md += "|-------------------|------------------|-------------------|\n"
            for entrada in historico_de_palavras:
                data_formatada = entrada['data'].strftime('%d/%m/%Y %H:%M') if isinstance(entrada['data'], datetime) else str(entrada['data'])
                palavra = entrada['palavra']
                sentimento = entrada.get('sentimento', 'N√£o classificado')
                output_md += f"| {data_formatada} | {palavra.capitalize():<16} | {sentimento.capitalize():<17} |\n"
            display(Markdown(output_md))
        else:
            display(Markdown("Seu hist√≥rico de palavras est√° vazio."))

    elif escolha == '4':
        display(Markdown("---"))
        df_historico = historico_para_dataframe(historico_de_palavras)
        if not df_historico.empty:
            baixar_historico_csv(df_historico)
        else:
            display(Markdown("<p style='color:orange;'>N√£o h√° dados no hist√≥rico para baixar.</p>"))

    elif escolha == '5':
        display(Markdown("---"))
        display(Markdown("## Ranking das Palavras Mais Frequentes"))
        periodo_ranking = input("Escolha o per√≠odo (semanal, mensal, total): ").lower()
        try:
            top_n_ranking_str = input("Quantas palavras deseja ver no ranking? (Digite um n√∫mero): ")
            top_n_ranking = int(top_n_ranking_str)
            if top_n_ranking <= 0:
                display(Markdown("<p style='color:red;'>Por favor, insira um n√∫mero positivo para o ranking.</p>"))
                continue

            # O ranking j√° usa as palavras registradas no hist√≥rico, que agora vir√£o da op√ß√£o 2
            ranking = obter_ranking_palavras(historico_de_palavras, periodo=periodo_ranking, top_n=top_n_ranking)

            if ranking:
                output_md = f"### Ranking ({periodo_ranking.capitalize()} - Top {top_n_ranking}):\n"
                for i, (palavra, frequencia) in enumerate(ranking):
                    output_md += f"{i+1}. **{palavra.capitalize()}**: {frequencia} ocorr√™ncia(s)\n"
                display(Markdown(output_md))
            else:
                display(Markdown(f"N√£o h√° palavras suficientes para gerar um ranking no per√≠odo '{periodo_ranking}' ou o hist√≥rico est√° vazio."))
        except ValueError:
            display(Markdown("<p style='color:red;'>Entrada inv√°lida para o n√∫mero de palavras. Por favor, digite um n√∫mero.</p>"))


    elif escolha == '6':
        display(Markdown("---"))
        display(Markdown("## Gr√°fico de Frequ√™ncia de Sentimentos"))
        periodo_sentimento = input("Escolha o per√≠odo (semanal, mensal, total): ").lower()

        # A frequ√™ncia j√° usa as palavras registradas no hist√≥rico, que agora vir√£o da op√ß√£o 2
        dados_frequencia = obter_frequencia_sentimento(historico_de_palavras, periodo=periodo_sentimento)

        if dados_frequencia:
            gerar_grafico_sentimento(dados_frequencia, periodo_sentimento)
        else:
            display(Markdown(f"<p style='color:orange;'>N√£o h√° dados de sentimento para gerar o gr√°fico no per√≠odo '{periodo_sentimento}'.</p>"))

    elif escolha == '7':
        display(Markdown("---"))
        confirmacao = input("Tem certeza que deseja limpar todo o hist√≥rico de palavras? (sim/n√£o): ").lower()
        if confirmacao == 'sim':
            historico_de_palavras = [] # Limpa a lista na mem√≥ria
            salvar_historico(ARQUIVO_HISTORICO) # Salva o arquivo JSON vazio
            display(Markdown("<p style='color:green;'>Hist√≥rico de palavras limpo com sucesso.</p>"))
        else:
            display(Markdown("<p style='color:blue;'>Limpeza do hist√≥rico cancelada.</p>"))

    elif escolha == '8':
        display(Markdown("---"))
        display(Markdown("### Obrigado por usar o Di√°rio de Sentimentos! At√© mais. üëã"))
        break # Sai do loop

    else:
        display(Markdown("<p style='color:red;'>**Escolha inv√°lida.** Por favor, digite um n√∫mero de 1 a 8.</p>"))
